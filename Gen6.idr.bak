\ ^outmost-fuel^ => \ outer^<cfg> => let export <Filesystems.FAT32.Filesystem>[0] : Data.Fuel.Fuel -> ({arg:16590} : Filesystems.FAT32.NodeParams) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ {arg:16593} => Filesystems.FAT32.Filesystem {arg:16590} {arg:16593})); export <Filesystems.FAT32.HVectMaybeNode.HVectMaybeNode>[0, 1] : Data.Fuel.Fuel -> ({arg:16367} : Filesystems.FAT32.NodeParams) -> (k : Prelude.Types.Nat) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair (Data.Monomorphic.Vect.VectNat.VectNat k) (\ ns => Builtin.DPair.DPair (Data.Monomorphic.Vect.VectNat.VectNat k) (\ ms => Builtin.DPair.DPair (Data.Monomorphic.Vect.HVectFinInc.HVectFinInc k ns) (\ {arg:16376} => Builtin.DPair.DPair (Data.Monomorphic.Vect.HVectFinInc.HVectFinInc k ms) (\ {arg:16379} => Filesystems.FAT32.HVectMaybeNode.HVectMaybeNode {arg:16367} k ns ms {arg:16376} {arg:16379}))))); export <Data.Nat.LTE>[1] : Data.Fuel.Fuel -> (m : Prelude.Types.Nat) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Data.Nat.LTE n m)); export <Prelude.Types.Nat>[] : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty Prelude.Types.Nat; export <Filesystems.FAT32.MaybeNode.MaybeNode>[0] : Data.Fuel.Fuel -> ({arg:16341} : Filesystems.FAT32.NodeParams) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Builtin.DPair.DPair Prelude.Types.Nat (\ m => Builtin.DPair.DPair (Data.FinInc.FinInc n) (\ {arg:16348} => Builtin.DPair.DPair (Data.FinInc.FinInc m) (\ {arg:16351} => Filesystems.FAT32.MaybeNode.MaybeNode {arg:16341} n m {arg:16348} {arg:16351}))))); export <Filesystems.FAT32.Node>[0] : Data.Fuel.Fuel -> ({arg:16451} : Filesystems.FAT32.NodeParams) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Builtin.DPair.DPair Prelude.Types.Nat (\ m => Builtin.DPair.DPair (Data.FinInc.FinInc n) (\ {arg:16458} => Builtin.DPair.DPair (Data.FinInc.FinInc m) (\ {arg:16461} => Filesystems.FAT32.Node {arg:16451} n m {arg:16458} {arg:16461}))))); export <Data.FinInc.FinInc>[] : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair ? (\ n => Data.FinInc.FinInc n)); export <Data.Nat.LTE>[] : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Builtin.DPair.DPair Prelude.Types.Nat (\ m => Data.Nat.LTE n m))); export <Filesystems.FAT32.Metadata>[] : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty Filesystems.FAT32.Metadata; export <Data.FinInc.FinInc>[0] : Data.Fuel.Fuel -> (n : ?) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Data.FinInc.FinInc n); export <Prelude.Basics.Bool>[] : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty Prelude.Basics.Bool; ^fuel_arg^ <Filesystems.FAT32.Filesystem>[0] inter^<{arg:16590}> = let export <<Filesystems.FAT32.Root>> : Data.Fuel.Fuel -> ({arg:16590} : Filesystems.FAT32.NodeParams) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ {arg:16593} => Filesystems.FAT32.Filesystem {arg:16590} {arg:16593})); ^cons_fuel^ <<Filesystems.FAT32.Root>> (Filesystems.FAT32.MkNodeParams clustSize clustNZ) = Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.Root (orders)") (((<Prelude.Types.Nat>[]) (^outmost-fuel^)) >>= (\ n => ((^outmost-fuel^) <Data.Nat.LTE>[1] (Data.Nat.div' (Prelude.Types.mult n clustSize) (Prelude.Types.mult n clustSize) (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S Prelude.Types.Z))))))))))))))))))))))))))))))))) >>= (\ {lamc:0} => case {lamc:0} of { Builtin.DPair.MkDPair k klte => ((<Filesystems.FAT32.HVectMaybeNode.HVectMaybeNode>[0, 1]) (^outmost-fuel^) (Filesystems.FAT32.MkNodeParams clustSize clustNZ) k) >>= (\ {lamc:0} => case {lamc:0} of { Builtin.DPair.MkDPair ns (Builtin.DPair.MkDPair ms (Builtin.DPair.MkDPair cs (Builtin.DPair.MkDPair ts entries))) => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Filesystems.FAT32.Root {clustSize = clustSize} {clustNZ = clustNZ} {n = n} {k = k} {klte = klte} {ns = ns} {ms = ms} {cs = cs} {ts = ts} entries)) }) }))); _ <<Filesystems.FAT32.Root>> _ = empty in Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.Filesystem[0] (non-recursive)") ((^fuel_arg^) <<Filesystems.FAT32.Root>> inter^<{arg:16590}>); (<Filesystems.FAT32.HVectMaybeNode.HVectMaybeNode>[0, 1]) ^fuel_arg^ inter^<{arg:16367}> inter^<k> = let export <<Filesystems.FAT32.HVectMaybeNode.Nil>> : Data.Fuel.Fuel -> ({arg:16367} : Filesystems.FAT32.NodeParams) -> (k : Prelude.Types.Nat) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair (Data.Monomorphic.Vect.VectNat.VectNat k) (\ ns => Builtin.DPair.DPair (Data.Monomorphic.Vect.VectNat.VectNat k) (\ ms => Builtin.DPair.DPair (Data.Monomorphic.Vect.HVectFinInc.HVectFinInc k ns) (\ {arg:16376} => Builtin.DPair.DPair (Data.Monomorphic.Vect.HVectFinInc.HVectFinInc k ms) (\ {arg:16379} => Filesystems.FAT32.HVectMaybeNode.HVectMaybeNode {arg:16367} k ns ms {arg:16376} {arg:16379}))))); export <<Filesystems.FAT32.HVectMaybeNode.(::)>> : Data.Fuel.Fuel -> ({arg:16367} : Filesystems.FAT32.NodeParams) -> (k : Prelude.Types.Nat) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair (Data.Monomorphic.Vect.VectNat.VectNat k) (\ ns => Builtin.DPair.DPair (Data.Monomorphic.Vect.VectNat.VectNat k) (\ ms => Builtin.DPair.DPair (Data.Monomorphic.Vect.HVectFinInc.HVectFinInc k ns) (\ {arg:16376} => Builtin.DPair.DPair (Data.Monomorphic.Vect.HVectFinInc.HVectFinInc k ms) (\ {arg:16379} => Filesystems.FAT32.HVectMaybeNode.HVectMaybeNode {arg:16367} k ns ms {arg:16376} {arg:16379}))))); (<<Filesystems.FAT32.HVectMaybeNode.Nil>>) ^cons_fuel^ cfg Prelude.Types.Z = Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.HVectMaybeNode.Nil (orders)") (Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Filesystems.FAT32.HVectMaybeNode.Nil {cfg = cfg})))))); (<<Filesystems.FAT32.HVectMaybeNode.Nil>>) _ _ _ = empty; (<<Filesystems.FAT32.HVectMaybeNode.(::)>>) ^cons_fuel^ cfg (Prelude.Types.S k) = Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.HVectMaybeNode.(::) (orders)") (((^cons_fuel^) <Filesystems.FAT32.MaybeNode.MaybeNode>[0] cfg) >>= (\ {lamc:0} => case {lamc:0} of { Builtin.DPair.MkDPair n (Builtin.DPair.MkDPair m (Builtin.DPair.MkDPair cur (Builtin.DPair.MkDPair tot ^bnd^{arg:16421}))) => ((<Filesystems.FAT32.HVectMaybeNode.HVectMaybeNode>[0, 1]) (^cons_fuel^) cfg k) >>= (\ {lamc:0} => case {lamc:0} of { Builtin.DPair.MkDPair ns (Builtin.DPair.MkDPair ms (Builtin.DPair.MkDPair cs (Builtin.DPair.MkDPair ts ^bnd^{arg:16424}))) => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Filesystems.FAT32.HVectMaybeNode.(::) {k = k} {cfg = cfg} {n = n} {ns = ns} {m = m} {ms = ms} {cur = cur} {tot = tot} {cs = cs} {ts = ts} (^bnd^{arg:16421}) (^bnd^{arg:16424})))))) }) })); (<<Filesystems.FAT32.HVectMaybeNode.(::)>>) _ _ _ = empty in case (^fuel_arg^) {- : Data.Fuel.Fuel -} of { Data.Fuel.Dry => Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.HVectMaybeNode.HVectMaybeNode[0, 1] (dry fuel)") ((<<Filesystems.FAT32.HVectMaybeNode.Nil>>) Data.Fuel.Dry inter^<{arg:16367}> inter^<k>); Data.Fuel.More ^sub^fuel_arg^ => Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.HVectMaybeNode.HVectMaybeNode[0, 1] (spend fuel)") (Test.DepTyCheck.Gen.frequency ((Builtin.MkPair Data.Nat1.one ((<<Filesystems.FAT32.HVectMaybeNode.Nil>>) (^fuel_arg^) inter^<{arg:16367}> inter^<k>)) :: ((Builtin.MkPair (Deriving.DepTyCheck.Util.Reflection.leftDepth (^sub^fuel_arg^)) ((<<Filesystems.FAT32.HVectMaybeNode.(::)>>) (^sub^fuel_arg^) inter^<{arg:16367}> inter^<k>)) :: Nil))) }; ^fuel_arg^ <Data.Nat.LTE>[1] inter^<m> = let export <<Data.Nat.LTEZero>> : Data.Fuel.Fuel -> (m : Prelude.Types.Nat) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Data.Nat.LTE n m)); export <<Data.Nat.LTESucc>> : Data.Fuel.Fuel -> (m : Prelude.Types.Nat) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Data.Nat.LTE n m)); ^cons_fuel^ <<Data.Nat.LTEZero>> right = Test.DepTyCheck.Gen.label (fromString "Data.Nat.LTEZero (orders)") (Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Data.Nat.LTEZero {right = right}))); ^cons_fuel^ <<Data.Nat.LTESucc>> (Prelude.Types.S right) = Test.DepTyCheck.Gen.label (fromString "Data.Nat.LTESucc (orders)") (((^cons_fuel^) <Data.Nat.LTE>[1] right) >>= (\ {lamc:0} => case {lamc:0} of { Builtin.DPair.MkDPair left ^bnd^{arg:2124} => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Data.Nat.LTESucc {right = right} {left = left} (^bnd^{arg:2124}))) })); _ <<Data.Nat.LTESucc>> _ = empty in case (^fuel_arg^) {- : Data.Fuel.Fuel -} of { Data.Fuel.Dry => Test.DepTyCheck.Gen.label (fromString "Data.Nat.LTE[1] (dry fuel)") (Data.Fuel.Dry <<Data.Nat.LTEZero>> inter^<m>); Data.Fuel.More ^sub^fuel_arg^ => Test.DepTyCheck.Gen.label (fromString "Data.Nat.LTE[1] (spend fuel)") (Test.DepTyCheck.Gen.frequency ((Builtin.MkPair Data.Nat1.one ((^fuel_arg^) <<Data.Nat.LTEZero>> inter^<m>)) :: ((Builtin.MkPair (Deriving.DepTyCheck.Util.Reflection.leftDepth (^sub^fuel_arg^)) ((^sub^fuel_arg^) <<Data.Nat.LTESucc>> inter^<m>)) :: Nil))) }; (<Prelude.Types.Nat>[]) ^fuel_arg^ = let export <<Prelude.Types.Z>> : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty Prelude.Types.Nat; export <<Prelude.Types.S>> : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty Prelude.Types.Nat; (<<Prelude.Types.Z>>) ^cons_fuel^ = Test.DepTyCheck.Gen.label (fromString "Prelude.Types.Z (orders)") (Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} Prelude.Types.Z); (<<Prelude.Types.S>>) ^cons_fuel^ = Test.DepTyCheck.Gen.label (fromString "Prelude.Types.S (orders)") (((<Prelude.Types.Nat>[]) (^cons_fuel^)) >>= (\ ^bnd^{arg:825} => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Prelude.Types.S (^bnd^{arg:825})))) in case (^fuel_arg^) {- : Data.Fuel.Fuel -} of { Data.Fuel.Dry => Test.DepTyCheck.Gen.label (fromString "Prelude.Types.Nat[] (dry fuel)") ((<<Prelude.Types.Z>>) Data.Fuel.Dry); Data.Fuel.More ^sub^fuel_arg^ => Test.DepTyCheck.Gen.label (fromString "Prelude.Types.Nat[] (spend fuel)") (Test.DepTyCheck.Gen.frequency ((Builtin.MkPair Data.Nat1.one ((<<Prelude.Types.Z>>) (^fuel_arg^))) :: ((Builtin.MkPair (Deriving.DepTyCheck.Util.Reflection.leftDepth (^sub^fuel_arg^)) ((<<Prelude.Types.S>>) (^sub^fuel_arg^))) :: Nil))) }; ^fuel_arg^ <Filesystems.FAT32.MaybeNode.MaybeNode>[0] inter^<{arg:16341}> = let export <<Filesystems.FAT32.MaybeNode.Nothing>> : Data.Fuel.Fuel -> ({arg:16341} : Filesystems.FAT32.NodeParams) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Builtin.DPair.DPair Prelude.Types.Nat (\ m => Builtin.DPair.DPair (Data.FinInc.FinInc n) (\ {arg:16348} => Builtin.DPair.DPair (Data.FinInc.FinInc m) (\ {arg:16351} => Filesystems.FAT32.MaybeNode.MaybeNode {arg:16341} n m {arg:16348} {arg:16351}))))); export <<Filesystems.FAT32.MaybeNode.Just>> : Data.Fuel.Fuel -> ({arg:16341} : Filesystems.FAT32.NodeParams) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Builtin.DPair.DPair Prelude.Types.Nat (\ m => Builtin.DPair.DPair (Data.FinInc.FinInc n) (\ {arg:16348} => Builtin.DPair.DPair (Data.FinInc.FinInc m) (\ {arg:16351} => Filesystems.FAT32.MaybeNode.MaybeNode {arg:16341} n m {arg:16348} {arg:16351}))))); ^cons_fuel^ <<Filesystems.FAT32.MaybeNode.Nothing>> cfg = Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.MaybeNode.Nothing (orders)") (((<Data.FinInc.FinInc>[]) (^outmost-fuel^)) >>= (\ {lamc:0} => case {lamc:0} of { Builtin.DPair.MkDPair m tot => ((<Data.FinInc.FinInc>[]) (^outmost-fuel^)) >>= (\ {lamc:0} => case {lamc:0} of { Builtin.DPair.MkDPair n cur => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Filesystems.FAT32.MaybeNode.Nothing {m = m} {tot = tot} {n = n} {cur = cur} {cfg = cfg}))))) }) })); ^cons_fuel^ <<Filesystems.FAT32.MaybeNode.Just>> cfg = Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.MaybeNode.Just (orders)") (((^cons_fuel^) <Filesystems.FAT32.Node>[0] cfg) >>= (\ {lamc:0} => case {lamc:0} of { Builtin.DPair.MkDPair n (Builtin.DPair.MkDPair m (Builtin.DPair.MkDPair tot (Builtin.DPair.MkDPair cur ^bnd^{arg:16362}))) => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Filesystems.FAT32.MaybeNode.Just {m = m} {cur = cur} {n = n} {tot = tot} {cfg = cfg} (^bnd^{arg:16362})))))) })) in case (^fuel_arg^) {- : Data.Fuel.Fuel -} of { Data.Fuel.Dry => Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.MaybeNode.MaybeNode[0] (dry fuel)") (Data.Fuel.Dry <<Filesystems.FAT32.MaybeNode.Nothing>> inter^<{arg:16341}>); Data.Fuel.More ^sub^fuel_arg^ => Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.MaybeNode.MaybeNode[0] (spend fuel)") (Test.DepTyCheck.Gen.frequency ((Builtin.MkPair Data.Nat1.one ((^fuel_arg^) <<Filesystems.FAT32.MaybeNode.Nothing>> inter^<{arg:16341}>)) :: ((Builtin.MkPair (Deriving.DepTyCheck.Util.Reflection.leftDepth (^sub^fuel_arg^)) ((^sub^fuel_arg^) <<Filesystems.FAT32.MaybeNode.Just>> inter^<{arg:16341}>)) :: Nil))) }; ^fuel_arg^ <Filesystems.FAT32.Node>[0] inter^<{arg:16451}> = let export <<Filesystems.FAT32.File>> : Data.Fuel.Fuel -> ({arg:16451} : Filesystems.FAT32.NodeParams) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Builtin.DPair.DPair Prelude.Types.Nat (\ m => Builtin.DPair.DPair (Data.FinInc.FinInc n) (\ {arg:16458} => Builtin.DPair.DPair (Data.FinInc.FinInc m) (\ {arg:16461} => Filesystems.FAT32.Node {arg:16451} n m {arg:16458} {arg:16461}))))); export <<Filesystems.FAT32.Dir>> : Data.Fuel.Fuel -> ({arg:16451} : Filesystems.FAT32.NodeParams) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Builtin.DPair.DPair Prelude.Types.Nat (\ m => Builtin.DPair.DPair (Data.FinInc.FinInc n) (\ {arg:16458} => Builtin.DPair.DPair (Data.FinInc.FinInc m) (\ {arg:16461} => Filesystems.FAT32.Node {arg:16451} n m {arg:16458} {arg:16461}))))); ^cons_fuel^ <<Filesystems.FAT32.File>> (Filesystems.FAT32.MkNodeParams clustSize clustNZ) = Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.File (orders)") (((<Prelude.Types.Nat>[]) (^outmost-fuel^)) >>= (\ n => ((^outmost-fuel^) <Data.FinInc.FinInc>[0] (Prelude.Types.mult n clustSize)) >>= (\ k => ((<Filesystems.FAT32.Metadata>[]) (^outmost-fuel^)) >>= (\ meta => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Filesystems.FAT32.File {clustSize = clustSize} {clustNZ = clustNZ} {n = n} {k = k} meta))))))))); _ <<Filesystems.FAT32.File>> _ = empty; ^cons_fuel^ <<Filesystems.FAT32.Dir>> (Filesystems.FAT32.MkNodeParams clustSize clustNZ) = Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.Dir (orders)") (((<Prelude.Types.Nat>[]) (^outmost-fuel^)) >>= (\ n => ((^outmost-fuel^) <Data.Nat.LTE>[1] (Data.Nat.divNatNZ (Prelude.Num.(*) {ty = Prelude.Types.Nat} {__con = Prelude.Types.Num implementation at Prelude.Types:66:1--71:33} n clustSize) Filesystems.FAT32.Constants.DirentSize (Data.Nat.SIsNonZero {x = Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S Prelude.Types.Z))))))))))))))))))))))))))))))}))) >>= (\ {lamc:0} => case {lamc:0} of { Builtin.DPair.MkDPair kv kp => ((<Filesystems.FAT32.HVectMaybeNode.HVectMaybeNode>[0, 1]) (^cons_fuel^) (Filesystems.FAT32.MkNodeParams clustSize clustNZ) kv) >>= (\ {lamc:0} => case {lamc:0} of { Builtin.DPair.MkDPair ns (Builtin.DPair.MkDPair ms (Builtin.DPair.MkDPair cs (Builtin.DPair.MkDPair ts entries))) => ((<Filesystems.FAT32.Metadata>[]) (^outmost-fuel^)) >>= (\ meta => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Filesystems.FAT32.Dir {clustSize = clustSize} {clustNZ = clustNZ} {n = n} {kv = kv} {kp = kp} {ns = ns} {ms = ms} {cs = cs} {ts = ts} meta entries)))))) }) }))); _ <<Filesystems.FAT32.Dir>> _ = empty in case (^fuel_arg^) {- : Data.Fuel.Fuel -} of { Data.Fuel.Dry => Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.Node[0] (dry fuel)") (Data.Fuel.Dry <<Filesystems.FAT32.File>> inter^<{arg:16451}>); Data.Fuel.More ^sub^fuel_arg^ => Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.Node[0] (spend fuel)") (Test.DepTyCheck.Gen.frequency ((Builtin.MkPair Data.Nat1.one ((^fuel_arg^) <<Filesystems.FAT32.File>> inter^<{arg:16451}>)) :: ((Builtin.MkPair (Deriving.DepTyCheck.Util.Reflection.leftDepth (^sub^fuel_arg^)) ((^sub^fuel_arg^) <<Filesystems.FAT32.Dir>> inter^<{arg:16451}>)) :: Nil))) }; (<Data.FinInc.FinInc>[]) ^fuel_arg^ = let export <<Data.FinInc.MkFinInc>> : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair ? (\ n => Data.FinInc.FinInc n)); (<<Data.FinInc.MkFinInc>>) ^cons_fuel^ = Test.DepTyCheck.Gen.label (fromString "Data.FinInc.MkFinInc (orders)") (((<Data.Nat.LTE>[]) (^outmost-fuel^)) >>= (\ {lamc:0} => case {lamc:0} of { Builtin.DPair.MkDPair val (Builtin.DPair.MkDPair n prf) => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Data.FinInc.MkFinInc {n = n} val prf)) })) in Test.DepTyCheck.Gen.label (fromString "Data.FinInc.FinInc[] (non-recursive)") ((<<Data.FinInc.MkFinInc>>) (^fuel_arg^)); (<Data.Nat.LTE>[]) ^fuel_arg^ = let export <<Data.Nat.LTEZero>> : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Builtin.DPair.DPair Prelude.Types.Nat (\ m => Data.Nat.LTE n m))); export <<Data.Nat.LTESucc>> : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Builtin.DPair.DPair Prelude.Types.Nat (\ m => Data.Nat.LTE n m))); (<<Data.Nat.LTEZero>>) ^cons_fuel^ = Test.DepTyCheck.Gen.label (fromString "Data.Nat.LTEZero (orders)") (((<Prelude.Types.Nat>[]) (^outmost-fuel^)) >>= (\ right => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Data.Nat.LTEZero {right = right}))))); (<<Data.Nat.LTESucc>>) ^cons_fuel^ = Test.DepTyCheck.Gen.label (fromString "Data.Nat.LTESucc (orders)") (((<Data.Nat.LTE>[]) (^cons_fuel^)) >>= (\ {lamc:0} => case {lamc:0} of { Builtin.DPair.MkDPair left (Builtin.DPair.MkDPair right ^bnd^{arg:2124}) => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Data.Nat.LTESucc {right = right} {left = left} (^bnd^{arg:2124})))) })) in case (^fuel_arg^) {- : Data.Fuel.Fuel -} of { Data.Fuel.Dry => Test.DepTyCheck.Gen.label (fromString "Data.Nat.LTE[] (dry fuel)") ((<<Data.Nat.LTEZero>>) Data.Fuel.Dry); Data.Fuel.More ^sub^fuel_arg^ => Test.DepTyCheck.Gen.label (fromString "Data.Nat.LTE[] (spend fuel)") (Test.DepTyCheck.Gen.frequency ((Builtin.MkPair Data.Nat1.one ((<<Data.Nat.LTEZero>>) (^fuel_arg^))) :: ((Builtin.MkPair (Deriving.DepTyCheck.Util.Reflection.leftDepth (^sub^fuel_arg^)) ((<<Data.Nat.LTESucc>>) (^sub^fuel_arg^))) :: Nil))) }; (<Filesystems.FAT32.Metadata>[]) ^fuel_arg^ = let export <<Filesystems.FAT32.MkMetadata>> : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty Filesystems.FAT32.Metadata; (<<Filesystems.FAT32.MkMetadata>>) ^cons_fuel^ = Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.MkMetadata (orders)") (((<Prelude.Basics.Bool>[]) (^outmost-fuel^)) >>= (\ readOnly => ((<Prelude.Basics.Bool>[]) (^outmost-fuel^)) >>= (\ hidden => ((<Prelude.Basics.Bool>[]) (^outmost-fuel^)) >>= (\ system => ((<Prelude.Basics.Bool>[]) (^outmost-fuel^)) >>= (\ archive => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Filesystems.FAT32.MkMetadata readOnly hidden system archive)))))) in Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.Metadata[] (non-recursive)") ((<<Filesystems.FAT32.MkMetadata>>) (^fuel_arg^)); ^fuel_arg^ <Data.FinInc.FinInc>[0] inter^<n> = let export <<Data.FinInc.MkFinInc>> : Data.Fuel.Fuel -> (n : ?) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Data.FinInc.FinInc n); ^cons_fuel^ <<Data.FinInc.MkFinInc>> n = Test.DepTyCheck.Gen.label (fromString "Data.FinInc.MkFinInc (orders)") (((^outmost-fuel^) <Data.Nat.LTE>[1] n) >>= (\ {lamc:0} => case {lamc:0} of { Builtin.DPair.MkDPair val prf => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Data.FinInc.MkFinInc {n = n} val prf) })) in Test.DepTyCheck.Gen.label (fromString "Data.FinInc.FinInc[0] (non-recursive)") ((^fuel_arg^) <<Data.FinInc.MkFinInc>> inter^<n>); (<Prelude.Basics.Bool>[]) ^fuel_arg^ = let export <<Prelude.Basics.False>> : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty Prelude.Basics.Bool; export <<Prelude.Basics.True>> : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty Prelude.Basics.Bool; (<<Prelude.Basics.False>>) ^cons_fuel^ = Test.DepTyCheck.Gen.label (fromString "Prelude.Basics.False (orders)") (Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} Prelude.Basics.False); (<<Prelude.Basics.True>>) ^cons_fuel^ = Test.DepTyCheck.Gen.label (fromString "Prelude.Basics.True (orders)") (Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} Prelude.Basics.True) in Test.DepTyCheck.Gen.label (fromString "Prelude.Basics.Bool[] (non-recursive)") (Test.DepTyCheck.Gen.oneOf {em = MaybeEmpty} (((<<Prelude.Basics.False>>) (^fuel_arg^)) :: (((<<Prelude.Basics.True>>) (^fuel_arg^)) :: Nil))) in (^outmost-fuel^) <Filesystems.FAT32.Filesystem>[0] outer^<cfg>
