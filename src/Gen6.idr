module Gen1

import public Deriving.DepTyCheck.Gen
import public Data.Fuel
import public Filesystems.FAT32

%default total

public export 
genFilesystem : Fuel -> (cfg : NodeParams) -> Gen MaybeEmpty (maxClust ** Filesystem cfg maxClust)
genFilesystem (^outmost-fuel^) (outer^<cfg>) = 
    let (<Filesystems.FAT32.Filesystem>) : Data.Fuel.Fuel -> (arg16325 : Filesystems.FAT32.NodeParams) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ arg16328 => Filesystems.FAT32.Filesystem arg16325 arg16328));
--         (<Filesystems.FAT32.HVectNode.HVectNode>[0, 1]) : Data.Fuel.Fuel -> (arg16270 : Filesystems.FAT32.NodeParams) -> (k : Prelude.Types.Nat) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair (Data.Monomorphic.Vect.VectNat.VectNat k) (\ ns => Builtin.DPair.DPair (Data.Monomorphic.Vect.HVectFinInc.HVectFinInc k ns) (\ arg16277 => Filesystems.FAT32.HVectNode.HVectNode arg16270 k ns arg16277)));
-- <Data.Nat.LTE>[1] : Data.Fuel.Fuel -> (m : Prelude.Types.Nat) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Data.Nat.LTE n m));
-- <Prelude.Types.Nat>[] : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty Prelude.Types.Nat;
-- <Filesystems.FAT32.Node>[0] : Data.Fuel.Fuel -> (arg16236 : Filesystems.FAT32.NodeParams) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Builtin.DPair.DPair (Data.FinInc.FinInc n) (\ arg16241 => Filesystems.FAT32.Node arg16236 n arg16241)));
-- <Data.FinInc.FinInc>[0] : Data.Fuel.Fuel -> (n : ?) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Data.FinInc.FinInc n);
-- ^fuel_arg^ <Filesystems.FAT32.Filesystem>[0] inter^<arg16325> = let <<Filesystems.FAT32.Root>> : Data.Fuel.Fuel -> (arg16325 : Filesystems.FAT32.NodeParams) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ arg16328 => Filesystems.FAT32.Filesystem arg16325 arg16328));
-- ^cons_fuel^ <<Filesystems.FAT32.Root>> (Filesystems.FAT32.MkNodeParams clustSize clustNZ) = Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.Root (orders)") (((<Prelude.Types.Nat>[]) (^outmost-fuel^)) >>= (\ n => ((^outmost-fuel^) <Data.Nat.LTE>[1] (Data.Nat.div' (Prelude.Types.mult n clustSize) (Prelude.Types.mult n clustSize) (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S (Prelude.Types.S Prelude.Types.Z))))))))))))))))))))))))))))))))) >>= (\ lamc0 => case lamc0 of { Builtin.DPair.MkDPair k klte => ((<Filesystems.FAT32.HVectNode.HVectNode>[0, 1]) (^outmost-fuel^) (Filesystems.FAT32.MkNodeParams clustSize clustNZ) k) >>= (\ lamc0 => case lamc0 of { Builtin.DPair.MkDPair ns (Builtin.DPair.MkDPair cs entries) => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Filesystems.FAT32.Root {clustSize = clustSize} {clustNZ = clustNZ} {n = n} {k = k} {klte = klte} {ns = ns} {cs = cs} entries)) }) })));
-- _ <<Filesystems.FAT32.Root>> _ = empty in Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.Filesystem[0] (non-recursive)") ((^fuel_arg^) <<Filesystems.FAT32.Root>> inter^<arg16325>);
-- (<Filesystems.FAT32.HVectNode.HVectNode>[0, 1]) ^fuel_arg^ inter^<arg16270> inter^<k> = let <<Filesystems.FAT32.HVectNode.Nil>> : Data.Fuel.Fuel -> (arg16270 : Filesystems.FAT32.NodeParams) -> (k : Prelude.Types.Nat) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair (Data.Monomorphic.Vect.VectNat.VectNat k) (\ ns => Builtin.DPair.DPair (Data.Monomorphic.Vect.HVectFinInc.HVectFinInc k ns) (\ arg16277 => Filesystems.FAT32.HVectNode.HVectNode arg16270 k ns arg16277)));
-- <<Filesystems.FAT32.HVectNode.(::)>> : Data.Fuel.Fuel -> (arg16270 : Filesystems.FAT32.NodeParams) -> (k : Prelude.Types.Nat) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair (Data.Monomorphic.Vect.VectNat.VectNat k) (\ ns => Builtin.DPair.DPair (Data.Monomorphic.Vect.HVectFinInc.HVectFinInc k ns) (\ arg16277 => Filesystems.FAT32.HVectNode.HVectNode arg16270 k ns arg16277)));
-- (<<Filesystems.FAT32.HVectNode.Nil>>) ^cons_fuel^ cfg Prelude.Types.Z = Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.HVectNode.Nil (orders)") (Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Filesystems.FAT32.HVectNode.Nil {cfg = cfg}))));
-- (<<Filesystems.FAT32.HVectNode.Nil>>) _ _ _ = empty;
-- (<<Filesystems.FAT32.HVectNode.(::)>>) ^cons_fuel^ cfg (Prelude.Types.S k) = Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.HVectNode.(::) (orders)") (((^outmost-fuel^) <Filesystems.FAT32.Node>[0] cfg) >>= (\ lamc0 => case lamc0 of { Builtin.DPair.MkDPair n (Builtin.DPair.MkDPair cur ^bnd^arg16305) => ((<Filesystems.FAT32.HVectNode.HVectNode>[0, 1]) (^cons_fuel^) cfg k) >>= (\ lamc0 => case lamc0 of { Builtin.DPair.MkDPair ns (Builtin.DPair.MkDPair cs ^bnd^arg16308) => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Filesystems.FAT32.HVectNode.(::) {k = k} {cfg = cfg} {n = n} {ns = ns} {cur = cur} {cs = cs} (^bnd^arg16305) (^bnd^arg16308)))) }) }));
-- (<<Filesystems.FAT32.HVectNode.(::)>>) _ _ _ = empty in case (^fuel_arg^) {- : Data.Fuel.Fuel -} of { Data.Fuel.Dry => Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.HVectNode.HVectNode[0, 1] (dry fuel)") ((<<Filesystems.FAT32.HVectNode.Nil>>) Data.Fuel.Dry inter^<arg16270> inter^<k>);
-- Data.Fuel.More ^sub^fuel_arg^ => Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.HVectNode.HVectNode[0, 1] (spend fuel)") (Test.DepTyCheck.Gen.frequency ((Builtin.MkPair Data.Nat1.one ((<<Filesystems.FAT32.HVectNode.Nil>>) (^fuel_arg^) inter^<arg16270> inter^<k>)) :: ((Builtin.MkPair (Deriving.DepTyCheck.Util.Reflection.leftDepth (^sub^fuel_arg^)) ((<<Filesystems.FAT32.HVectNode.(::)>>) (^sub^fuel_arg^) inter^<arg16270> inter^<k>)) :: Nil))) };
-- ^fuel_arg^ <Data.Nat.LTE>[1] inter^<m> = let <<Data.Nat.LTEZero>> : Data.Fuel.Fuel -> (m : Prelude.Types.Nat) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Data.Nat.LTE n m));
-- <<Data.Nat.LTESucc>> : Data.Fuel.Fuel -> (m : Prelude.Types.Nat) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Data.Nat.LTE n m));
-- ^cons_fuel^ <<Data.Nat.LTEZero>> right = Test.DepTyCheck.Gen.label (fromString "Data.Nat.LTEZero (orders)") (Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Data.Nat.LTEZero {right = right})));
-- ^cons_fuel^ <<Data.Nat.LTESucc>> (Prelude.Types.S right) = Test.DepTyCheck.Gen.label (fromString "Data.Nat.LTESucc (orders)") (((^cons_fuel^) <Data.Nat.LTE>[1] right) >>= (\ lamc0 => case lamc0 of { Builtin.DPair.MkDPair left ^bnd^arg2124 => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Data.Nat.LTESucc {right = right} {left = left} (^bnd^arg2124))) }));
-- _ <<Data.Nat.LTESucc>> _ = empty in case (^fuel_arg^) {- : Data.Fuel.Fuel -} of { Data.Fuel.Dry => Test.DepTyCheck.Gen.label (fromString "Data.Nat.LTE[1] (dry fuel)") (Data.Fuel.Dry <<Data.Nat.LTEZero>> inter^<m>);
-- Data.Fuel.More ^sub^fuel_arg^ => Test.DepTyCheck.Gen.label (fromString "Data.Nat.LTE[1] (spend fuel)") (Test.DepTyCheck.Gen.frequency ((Builtin.MkPair Data.Nat1.one ((^fuel_arg^) <<Data.Nat.LTEZero>> inter^<m>)) :: ((Builtin.MkPair (Deriving.DepTyCheck.Util.Reflection.leftDepth (^sub^fuel_arg^)) ((^sub^fuel_arg^) <<Data.Nat.LTESucc>> inter^<m>)) :: Nil))) };
-- (<Prelude.Types.Nat>[]) ^fuel_arg^ = let <<Prelude.Types.Z>> : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty Prelude.Types.Nat;
-- <<Prelude.Types.S>> : Data.Fuel.Fuel -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty Prelude.Types.Nat;
-- (<<Prelude.Types.Z>>) ^cons_fuel^ = Test.DepTyCheck.Gen.label (fromString "Prelude.Types.Z (orders)") (Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} Prelude.Types.Z);
-- (<<Prelude.Types.S>>) ^cons_fuel^ = Test.DepTyCheck.Gen.label (fromString "Prelude.Types.S (orders)") (((<Prelude.Types.Nat>[]) (^cons_fuel^)) >>= (\ ^bnd^arg825 => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Prelude.Types.S (^bnd^arg825)))) in case (^fuel_arg^) {- : Data.Fuel.Fuel -} of { Data.Fuel.Dry => Test.DepTyCheck.Gen.label (fromString "Prelude.Types.Nat[] (dry fuel)") ((<<Prelude.Types.Z>>) Data.Fuel.Dry);
-- Data.Fuel.More ^sub^fuel_arg^ => Test.DepTyCheck.Gen.label (fromString "Prelude.Types.Nat[] (spend fuel)") (Test.DepTyCheck.Gen.frequency ((Builtin.MkPair Data.Nat1.one ((<<Prelude.Types.Z>>) (^fuel_arg^))) :: ((Builtin.MkPair (Deriving.DepTyCheck.Util.Reflection.leftDepth (^sub^fuel_arg^)) ((<<Prelude.Types.S>>) (^sub^fuel_arg^))) :: Nil))) };
-- ^fuel_arg^ <Filesystems.FAT32.Node>[0] inter^<arg16236> = let <<Filesystems.FAT32.File>> : Data.Fuel.Fuel -> (arg16236 : Filesystems.FAT32.NodeParams) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Builtin.DPair.DPair Prelude.Types.Nat (\ n => Builtin.DPair.DPair (Data.FinInc.FinInc n) (\ arg16241 => Filesystems.FAT32.Node arg16236 n arg16241)));
-- ^cons_fuel^ <<Filesystems.FAT32.File>> (Filesystems.FAT32.MkNodeParams clustSize clustNZ) = Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.File (orders)") (((<Prelude.Types.Nat>[]) (^outmost-fuel^)) >>= (\ n => ((^outmost-fuel^) <Data.FinInc.FinInc>[0] (Prelude.Types.mult n clustSize)) >>= (\ k => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Builtin.DPair.MkDPair _ (Builtin.DPair.MkDPair _ (Filesystems.FAT32.File {clustSize = clustSize} {clustNZ = clustNZ} {n = n} {k = k}))))));
-- _ <<Filesystems.FAT32.File>> _ = empty in Test.DepTyCheck.Gen.label (fromString "Filesystems.FAT32.Node[0] (non-recursive)") ((^fuel_arg^) <<Filesystems.FAT32.File>> inter^<arg16236>);
-- ^fuel_arg^ <Data.FinInc.FinInc>[0] inter^<n> = let <<Data.FinInc.MkFinInc>> : Data.Fuel.Fuel -> (n : ?) -> Test.DepTyCheck.Gen.Gen Test.DepTyCheck.Gen.Emptiness.MaybeEmpty (Data.FinInc.FinInc n);
-- ^cons_fuel^ <<Data.FinInc.MkFinInc>> n = Test.DepTyCheck.Gen.label (fromString "Data.FinInc.MkFinInc (orders)") (((^outmost-fuel^) <Data.Nat.LTE>[1] n) >>= (\ lamc0 => case lamc0 of { Builtin.DPair.MkDPair val prf => Prelude.pure {f = Test.DepTyCheck.Gen.Gen _} (Data.FinInc.MkFinInc {n = n} val prf) })) in Test.DepTyCheck.Gen.label (fromString "Data.FinInc.FinInc[0] (non-recursive)") ((^fuel_arg^) <<Data.FinInc.MkFinInc>> inter^<n>) 
    in (^outmost-fuel^) (<Filesystems.FAT32.Filesystem>) (outer^<cfg>)
